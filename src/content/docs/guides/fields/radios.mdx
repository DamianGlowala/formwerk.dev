---
title: Radio Buttons
description: A guide in my new Starlight docs site.
sidebar:
  order: 3
---

import { Aside } from '@astrojs/starlight/components';
import AnatomyCanvas from '@components/AnatomyCanvas.vue';
import AnatomyRadio from '@components/AnatomyRadio.vue';
import MdxRepl from '@components/MdxRepl.vue';
import Kbd from '@components/KeyboardKey.vue';

import RadioGroupPartial from './_partials/_radioGroup.mdx';
import RadioInputPartial from './_partials/_radioInput.mdx';
import RadioItemPartial from './_partials/_radioItem.mdx';
import StyledRadioInputPartial from './_partials/_styledRadioInput.mdx';
import StyledRadioGroup from './_partials/_styledRadioGroup.mdx';
import StyledCustomRadioPartial from './_partials/_styledCustomRadio.mdx';

> A radio group is a set of checkable buttons, known as radio buttons, where no more than one of the buttons can be checked at a time. Some implementations may initialize the set with all buttons in the unchecked state in order to force the user to check one of the buttons before moving past a certain point in the workflow.

Radios in HTML do not have a "group" concept, but they get grouped implicitly by the "name" attribute. This isn't the case in Vue and most UI libraries, as they are grouped by the model name they mutate.

Formwerk follows the "group" concept to provide a consistent API for radio fields regardless if they are bound to the same model or if they have the same name or not.

This means radios are a compound field, meaning they require more than one composable to work properly and by extension, you need to build more than one component to make them work.

For radios you will use the `useRadioGroup` and `useRadio` composables in order to build radio components.

## Features

You can build radio components using either the native HTML `input[type="radio"]` elements or custom HTML elements. We provide the behavior, state and accessibility implementation for both cases with the same API and features.

The following features are implemented:

- Support for either `input[type="radio"]` or custom HTML elements as a base element for the radio component.
- Labeling, descriptions, error message displays are automatically linked to input and label elements with `aria-*` attributes.
- Form management, data collection and validation with Typed Schemas or native HTML5 validation.
- Support for orientation with `horizontal` and `vertical` values.
- `v-model` support for radio groups.
- Supported Keyboard features:

| Key                                          | Description                                                                      |
| -------------------------------------------- | -------------------------------------------------------------------------------- |
| <Kbd code="ArrowDown" label="ArrowDown"  />  | Focuses the next radio item in the group.                                        |
| <Kbd code="ArrowRight" label="ArrowRight" /> | Focuses the next radio item in the group. in RTL, focuses the previous item.     |
| <Kbd code="ArrowLeft" label="Arrow Left" />  | Focuses the previous radio item in the group.                                    |
| <Kbd code="ArrowUp" label="Arrow Up" />      | Focuses the previous radio item in the group. In RTL, focuses the next item.     |
| <Kbd code="Tab" label="Tab" />               | Focuses the selected item in the group. If none selected, focuses the first one. |
| <Kbd code="Space" label="Space" />           | Selects the focused radio item.                                                  |

## Anatomy

<AnatomyCanvas>
  <AnatomyRadio />
</AnatomyCanvas>

## Building a Radio Group Component

The `useRadioGroup` provides the behavior, state and accessibility implementation for group components.

Unlike checkboxes, radio components **MUST** be grouped by a radio group component. Which is why we will start by building a `RadioGroup` component as a perquisite. We will be using this component in following examples throughout this page.

<RadioGroupPartial />

## Building a Radio Component

With the Radio Group component built, we can now build a `RadioItem` component. You will be using the `useRadio` composable to build it.

You can use either the native HTML `input[type="radio"]` element or custom HTML elements. Doesn't matter which one you choose, both have the same exact API and Formwerk does the work needed for each case behind the scenes.

```ts
import { type RadioProps, useRadio } from '@formwerk/core';

const props = defineProps<RadioProps>();

const { labelProps, inputProps } = useRadio(props);
```

The most important part is to bind the `inputProps` object to the base element, the element that you consider it to be the radio button. We also provide the `RadioProps` type for you to use as your component props. You are not required to use it but it is recommended to make use of the full feature set of the `useRadio` composable and by extension, your component.

With the basics out of the way, let's build a radio component with two common variations.

### With `input` element as a base

You can use the `useRadio` composable to build a radio component with the `input` element as a base.

<MdxRepl client:load>

<div slot="RadioItem.vue">

<RadioInputPartial />

</div>

<div slot="!RadioGroup.vue">
  <RadioGroupPartial />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';
</script>

<template>
  <RadioGroup label="Radio Group">
    <RadioItem label="Radio 1" value="1" />
    <RadioItem label="Radio 2" value="2" />
    <RadioItem label="Radio 3" value="3" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

The style-ability last example is limited to the styling capabilities of the native `input` element. To work around that check the [styling section](#styling).

### With custom HTML element as a base

For unlimited styling freedom, you don't have to use the `input` element. With the same API you can use custom HTML elements as a binding target for `inputProps` object.

In the following example we are using a `span` element as a base element for the radio. Try keyboard navigation, clicking, focusing and other interactions to see how it behaves.

<MdxRepl client:load>

<div slot="RadioItem.vue">
  <RadioItemPartial />
</div>

<div slot="!RadioGroup.vue">
  <RadioGroupPartial />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';
</script>

<template>
  <RadioGroup label="Radio Group">
    <RadioItem label="Radio 1" value="1" />
    <RadioItem label="Radio 2" value="2" />
    <RadioItem label="Radio 3" value="3" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

## Validation

Radio components support validation with native HTML5 constraints or typed schemas. However, the `useRadioGroup` is the one that accepts validation props.

### HTML Constraint Validation

The following properties are supported on `useRadioGroup` and `useRadio` that use the `input` element as a base. Custom elements do not support these properties.

| Name       | Type      | Description                           |
| ---------- | --------- | ------------------------------------- |
| `required` | `boolean` | Whether the number field is required. |

<MdxRepl client:load>

<div slot="!Radio.vue">
  <RadioInputPartial />
</div>

<div slot="!RadioGroup.vue">
  <RadioGroupPartial />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import Radio from './Radio.vue';
import RadioGroup from './RadioGroup.vue';
</script>

<template>
  <RadioGroup label="Radio Group" required>
    <Radio label="Radio 1" value="1" />
    <Radio label="Radio 2" value="2" />
    <Radio label="Radio 3" value="3" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

### Typed Schema

`useRadioGroup` also supports Typed Schema validation through the `schema` prop.

<Aside>

Depending on the schema validation provider you are using, the API might slightly differ. Check the supported validation providers for more information. In this example we are using the `zod` schema validation provider.

</Aside>

Here is an example of using zod as a typed schema to validate the radio group, we will be using the radio item component from the previous examples.

<MdxRepl client:load>

<div slot="!RadioItem.vue">
  <RadioItemPartial />
</div>

<div slot="!RadioGroup.vue">
  <RadioGroupPartial />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';
import { z } from 'zod';
import { defineSchema } from '@formwerk/schema-zod';

const schema = defineSchema(
  z.string().min(1, 'Please select a drink').endsWith('‚òïÔ∏è', 'WRONG ANSWER!'),
);
</script>

<template>
  <RadioGroup label="Select a drink" :schema="schema">
    <RadioItem label="Tea" value="üçµ" />
    <RadioItem label="Coffee" value="‚òïÔ∏è" />
    <RadioItem label="Milk" value="ü•õ" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

## Styling

Formwerk does not come with any markup or styling, which is often the parts that make a design system unique. That means you can use any styling solution you want, whether it's [TailwindCSS](https://tailwindcss.com/), or plain CSS.

In this example we will work around the styling limitations of the native `input` element by visually hiding it and wrapping it inside the `label` element to maintain its accessible behavior.

<MdxRepl client:load>

<div slot="RadioItem.vue">
  <StyledRadioInputPartial />
</div>

<div slot="RadioGroup.vue">
  <StyledRadioGroup />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import { z } from 'zod';
import { defineSchema } from '@formwerk/schema-zod';
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';

const schema = defineSchema(
  z.string().min(1, 'Please select a drink').endsWith('‚òïÔ∏è', 'WRONG ANSWER!'),
);
</script>

<template>
  <RadioGroup
    label="Select a drink"
    description="There is only one right answer"
    :schema="schema"
  >
    <RadioItem label="Tea üçµ" value="üçµ" />
    <RadioItem label="Coffee ‚òïÔ∏è" value="‚òïÔ∏è" />
    <RadioItem label="Milk ü•õ" value="ü•õ" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

You can alternatively use custom HTML elements as a base for the radio component without having to visually hide the `input` element. But since you won't have any of the input pseudo classes, they will instead be replaced with `aria-*` attributes.

Here is the same example with custom HTML elements as a base.

<MdxRepl client:load>

<div slot="RadioItem.vue">
  <StyledCustomRadioPartial />
</div>

<div slot="RadioGroup.vue">
  <StyledRadioGroup />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import { z } from 'zod';
import { defineSchema } from '@formwerk/schema-zod';
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';

const schema = defineSchema(
  z
    .string()
    .min(1, { message: 'Please select a drink' })
    .endsWith('‚òïÔ∏è', { message: 'WRONG ANSWER!' }),
);
</script>

<template>
  <RadioGroup
    label="Select a drink"
    description="There is only one right answer"
    :schema="schema"
  >
    <RadioItem label="Tea üçµ" value="üçµ" />
    <RadioItem label="Coffee ‚òïÔ∏è" value="‚òïÔ∏è" />
    <RadioItem label="Milk ü•õ" value="ü•õ" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

## Usage

### Disabled

You can disable individual radio items or the whole group with the `disabled` prop on either. Disabled radio items are not focusable. Disabled groups are not submitted and are not validated.

We made use of the styled radio component that we created above to make it clearer that the radio items are disabled.

<MdxRepl client:load>

<div slot="!RadioItem.vue">
  <StyledRadioInputPartial />
</div>

<div slot="!RadioGroup.vue">
  <StyledRadioGroup />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';
</script>

<template>
  <RadioGroup label="Radio Group">
    <RadioItem label="Radio 1" value="1" />
    <RadioItem label="Radio 2" value="2" />
    <RadioItem label="Radio 3" value="3" disabled />
    <RadioItem label="Radio 3" value="4" />
  </RadioGroup>

  <RadioGroup label="Disabled Group" disabled>
    <RadioItem label="Radio 1" value="1" />
    <RadioItem label="Radio 2" value="2" />
    <RadioItem label="Radio 3" value="3" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

If you need to prevent the user from interacting with the group while still allowing it to submit, consider using `readonly` instead.

### Readonly

Only available on the group, the `readonly` prop prevents the user from interacting with the group while still allowing it to submit and be validated.

<MdxRepl client:load>

<div slot="!RadioItem.vue">
  <StyledRadioInputPartial />
</div>

<div slot="!RadioGroup.vue">
  <StyledRadioGroup />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import { ref } from 'vue';
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';

const value = ref('‚òïÔ∏è');
</script>

<template>
  <RadioGroup
    label="Select a drink"
    v-model="value"
    description="Can't change this"
    readonly
  >
    <RadioItem label="Tea üçµ" value="üçµ" />
    <RadioItem label="Coffee ‚òïÔ∏è" value="‚òïÔ∏è" />
    <RadioItem label="Milk ü•õ" value="ü•õ" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

### Orientation

Radio group accept an `orientation` prop that can be set to `horizontal` or `vertical`. The orientation does not affect the focus order, but you can use it to layout the radio items in a row or column with CSS.

There is not default value assumed for the orientation, but if it is provided the group element will have a `aria-orientation` attribute set to the value of the prop. So you can use that to style it.

<MdxRepl client:load>

<div slot="!RadioItem.vue">
  <StyledRadioInputPartial />
</div>

<div slot="!RadioGroup.vue">
  <StyledRadioGroup />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';
</script>

<template>
  <RadioGroup label="Radio Group" orientation="vertical">
    <RadioItem label="Radio 1" value="1" />
    <RadioItem label="Radio 2" value="2" />
    <RadioItem label="Radio 3" value="3" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

### RTL

The radio group accepts a `dir` prop that can be set to `ltr` or `rtl`. Unlike the orientation, the `dir` prop affects the focus order of the radio items as the Left and Right arrow keys will navigate the items in the opposite direction.

<MdxRepl client:load>

<div slot="!RadioItem.vue">
  <StyledRadioInputPartial />
</div>

<div slot="!RadioGroup.vue">
  <StyledRadioGroup />
</div>

<div slot="App.vue">

```vue
<script setup lang="ts">
import RadioItem from './RadioItem.vue';
import RadioGroup from './RadioGroup.vue';
</script>

<template>
  <RadioGroup label="RTL Group" dir="rtl">
    <RadioItem label="Radio 1" value="1" />
    <RadioItem label="Radio 2" value="2" />
    <RadioItem label="Radio 3" value="3" />
  </RadioGroup>
</template>
```

</div>

</MdxRepl>

<Aside>

There is a lot more to directionality and localization, for more info check out the [i18n guide](/guides/extras/i18n).

</Aside>

## API

Most of the values expressed below are wrapped in `Ref` as they are reactive values.

### Radio Group

#### Props

| Name                    | Type                  | Description                                                |
| ----------------------- | --------------------- | ---------------------------------------------------------- |
| `orientation`           | `Orientation`         | The orientation of the radio group.                        |
| `dir`                   | `Direction`           | The direction of the radio group.                          |
| `label`                 | `string`              | The label of the radio group.                              |
| `description`           | `string`              | The description of the radio group.                        |
| `name`                  | `string`              | The name attribute of the radio group.                     |
| `modelValue`            | `TValue`              | The value of the radio group.                              |
| `disabled`              | `boolean`             | If the radio group is disabled.                            |
| `readonly`              | `boolean`             | If the radio group is readonly.                            |
| `required`              | `boolean`             | If the radio group is required.                            |
| `schema`                | `TypedSchema<TValue>` | The typed schema for validation of the radio group.        |
| `disableHtmlValidation` | `boolean`             | If HTML validation should be disabled for the radio group. |

#### Returns

| Name                | Type                               | Description                                                                |
| ------------------- | ---------------------------------- | -------------------------------------------------------------------------- |
| `descriptionProps`  | `AriaDescriptionProps`             | The group's description element props.                                     |
| `displayError`      | `() => string \| undefined`        | A getter to display the error message if touched.                          |
| `errorMessage`      | `string \| undefined`              | The group's first error message.                                           |
| `errorMessageProps` | `AriaErrorMessageProps`            | The group's error message element props.                                   |
| `errors`            | `string[]`                         | The group's error messages.                                                |
| `fieldValue`        | `any[]`                            | The group's value.                                                         |
| `groupProps`        | `AriaGroupProps`                   | The group's element props.                                                 |
| `isDirty`           | `boolean`                          | If the group is dirty, that is if the group value has changed.             |
| `isTouched`         | `boolean`                          | If the group is touched, that is if at least one checkbox item is touched. |
| `isValid`           | `boolean`                          | If the group has any error messages.                                       |
| `labelProps`        | `AriaLabelProps`                   | The group's label element props.                                           |
| `setErrors`         | `(msg: Arrayable<string>) => void` | Sets the error messages for the group and sets the `isValid` state.        |
| `setTouched`        | `(touched: boolean) => void`       | Sets the `isTouched` state.                                                |
| `setValue`          | `(value: any[]) => void`           | Sets the group value and updates the selected item checked state.          |

### Radio

#### Props

| Name       | Type      | Description                                                  |
| ---------- | --------- | ------------------------------------------------------------ |
| `value`    | `TValue`  | The radio's value. Will be used to track its selected state. |
| `label`    | `string`  | The radio's label.                                           |
| `disabled` | `boolean` | If the radio is disabled.                                    |

#### Returns

| Name         | Type             | Description                      |
| ------------ | ---------------- | -------------------------------- |
| `inputProps` | Complex Binding  | The radio's base element props.  |
| `isChecked`  | `boolean`        | If the radio is checked.         |
| `isDisabled` | `boolean`        | If the radio is disabled.        |
| `labelProps` | `AriaLabelProps` | The radio's label element props. |
